<!DOCTYPE HTML>
<html lang="en-US">

<head>
	<meta charset="UTF-8">

	<link rel="shortcut icon" href="../resources/favicon.jpg">
	<title>Control Structures</title>
	
	<link rel="stylesheet" type="text/css" href="../styles/base.css">
	<link rel="stylesheet" type="text/css" href="../styles/scrollbar.css">
	<base target="_blank">
</head>

<body>
	<div id="bodycontent">
	
		<br>
		<h4><p><a target="_self" href="../index.html">Home</a></p></h4>
		<h1>Control Structures</h1>
		<hr>
		
		<h3><p>Please note that any code on this page is <a href="https://economictimes.indiatimes.com/definition/pseudocode"><i>pseudocode</i></a>, meaning it won't work in any actual programming language.</p></h3>
		
		<h2>Control Structures</h2>
		
		<h3>
			<p>
				<i>Control structures</i> are integral parts of programs as they allow us to set the 'flow' of the program.
				There are a few types of control structures: sequencial, conditional, and iterative (looping).
				These basically govern which statements will be executed and in what order, allowing us to <i>implement</i> many more algorithms.
				To implement an algorithm means to take the central idea of the algorithm, such as summing up a list of numbers, and write code which performs that algorithm.
			</p>
		</h3>
		
		<h2>Sequence</h2>
		
		<h3>
			<p>
				Sequential execution of code is the normal, vanilla default for how code is executed.
				If we have several statements in a row, they will be executed from top to bottom and left to right, barring the introduction of other control structures.
				In the example below, statements will be executed in order according to their numbers.
			</p>
			<div class="codeinset">
				<code>statement 1</code><br>
				<code>statement 2</code><br>
				<code>statement 3</code><br>
				<code>statement 4</code><br>
			</div>
			<p>
				When programming, it's best to think of the computer like a person literally reading your program.
				A person would have one instruction in their head at a time, and would move to the next instruction depending on the placement of your control structures.
				Similarly, program execution moves through your program one statement at a time, directed by the control structures.
			</p>
		</h3>
		
		<h2>Conditionals</h2>
		
		<h3>
			<p>
				Conditionals are useful control structures which allow us to create <i>branches</i>, which basically say "If thing X is true, do thing Y."
				Unsurprisingly, the main conditional structure is called the <code>if</code> conditional, which takes the form of a <i>block</i>.
				The block of code starts at the <code>if</code> <i>keyword</i> and goes all the way to the closing brace (or curly-brace, if you prefer that).
				A keyword is a special word which cannot be used as a variable name because it tells the computer to do something specific where it appears.
				In this case, when the computer runs across the word <code>if</code> it knows we are about to use a conditional.
				If we tried to do <code>int if = 10;</code>, we would get an error.
				An <code>if</code> statement looks something like this:
			</p>
			<div class="codeinset">
				<code>IF (some condition):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do this</code><br>
				<code>}</code><br>
			</div>
			<p>
				In the code above, if the expression <code>some condition</code> evaluates to True, the statement <code>do this</code> is run.
				If the expression evaluates to False, the statement inside the block is not executed, and the entire <code>if</code> block is skipped.
			</p>
			<p>
				A slightly more upgraded conditional is the <code>else if</code> conditional.
				This has to follow an <code>if</code> conditional, and forms chains of linked conditionals.
				It basically does what it says:
				if the original <code>if</code> statement fails (meaning the condition was not met), the computer will check if the <code>else if</code> condition is true, and if so, will 'go into' that block.
				'Go into' is programmer speak for execution moving into a specific code block or section of code.
				If neither condition passes, both blocks will be skipped, similar to the single <code>if</code> block above; if the first condition passes, the whole <code>else if</code> block will be skipped, and its condition will not even be evaluated.
				This is because it is an <code><i>else</i> if</code>: it only can happen if the first possibility doesn't.
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition B):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
			</div>
			<p>
				In this case, if condition A is met, <code>do a</code> is executed.
				If condition A is not met, but condition B is, <code>do b</code> will b executed.
				If neither condition A nor condition B are met, the whole block will be skipped.
			</p>
			<p>
				We can actually string as many <code>else if</code> blocks together as we want, forming long conditional chains.
				Here's an example with three <code>else if</code> blocks:
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition B):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition C)</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
				<code>ELSE IF(condition D)</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do d</code><br>
				<code>}</code><br>
			</div>
			<p>
				This is actually why we call an if statement a branch: in this block, one statement (and only one) will be executed, and the different possibilities stick out like branches from a tree.
				If any condition is met, the corresponding statement is executed, and then execution drops down to past the last <code>else if</code> block, even if multiple conditions are true.
				If condition A and B are true, but C and D are false, only <code>do a</code> will actually be executed.
				The computer won't even check to see if conditions B, C, and D are true or not.
				This is why the order matters when you are programming.
				If none of the conditions is met, nothing inside the chain runs (is executed) and execution moves down below the last <code>else if</code>.
			</p>
			<p>
				Finally, there is one more conditional, the humble <code>else</code> block.
				It functions much as the <code>else if</code> block from above, in that it has to follow an <code>if</code> or <code>else if</code> statement.
				It also only executes if all conditional statements linked to it above don't execute. Once you put an else, you cannot link any more conditionals below it.
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
			</div>
			<p>
				It's quite self-explanatory: if A is true, do a; if A is not true, do b.
				If A is true, b will not happen, because b only happens if A is not true.
				Please note that in this case, unlike an <code>if</code> or <code>else if</code> chain, where no statement is guaranteed to be executed, either statement <code>a</code> or statement <code>b</code> will be executed.
				We may not know ahead of time which one it will be, but we are guaranteed that one of them will run.
			</p>
			<p>
				We can also use the <code>else</code> block in conjunction with the <code>else if</code> block:
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition B):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition C)</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
				<code>ELSE</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do d</code><br>
				<code>}</code><br>
			</div>
			<p>
				In this chain, one statement will run, unlike the chain made up only of <code>else if</code> blocks, where there is a possibility of no statement in the chain running.
				Either a, b, or c will be executed, depending on which is the first true condition out of conditions A, B, or C.
				If none of those conditions are true, d will run.
			</p>
			<p>
				The chain-like nature of <code>else if</code> blocks means that an <code>if</code> followed by two <code>else if</code> blocks can be very different from three <code>if</code> blocks:
			</p>
			Code Snippet #1:
			<div class="codeinset">
				<code>IF A:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF B:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>ELSE IF C:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
			</div>
			Code Snippet #2:
			<div class="codeinset">
				<code>IF A:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>IF B:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>IF C:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
			</div>
			<p>
				In the first code snippet, which is a single conditional chain made of three blocks, only one of a, b, and c will run, or none of them will run.
			</p>
			<p>
				In the second code snippet, which is three independent conditional blocks, execution doesn't drop to the end of the chain when a statement is run because there <i>is</i> no chain.
				There is a possibility of a, b, <i>and</i> c running, because the only thing determining whether a statement runs is its associated conditional.
				Just because A is true and a runs doesn't mean B won't be true, causing b to run. a and b could run, or a and c, or b and c, or just a, just b, just c, or all three.
				If A, B, and C all turn out to be false, none of a, b, or c could run.
			</p>
		</h3>
		
		<h2>Loops</h2>
		
		<h3>
			<p>
				The last programming structure is the iterative structure, which essentially involves running the same code multiple times.
				Different programming languages have various syntaxes and structures to do this, but almost all of them have <code>while</code> loops, so we'll focus on those.
				A while loop is very similar to an <code>if</code> conditional: it has a condition (which should be an expression which evaluates to true or false) and a body (a set of statements to be run).
				However, the difference is that where an <code>if</code> conditional only runs the block once, a <code>while</code> loops runs the block of code indefinitely, only stopping if the condition becomes false.
				Here's an example of a basic while loop:
			</p>
			<div class="codeinset">
				<code>WHILE (condition):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do this</code><br>
				<code>}</code><br>
			</div>
			<p>
				To understand it a little better, we need to look at a real example:
			</p>
			<div class="codeinset">
				<code>int i = 0;</code><br>
				<code>WHILE (i &lt; 10):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;i = i++;</code><br>
				<code>}</code><br>
			</div>
			<p>
				If this is the first real segment of code you've seen, don't worry: we'll break it down.
				The first statement tells the computer that we are going to create a variable called <code>i</code>.
				This variable will be an <code>int</code> type variable and will have the value of 0.
				Now, we come to a <code>while</code> loop, where our condition says that the code inside the while loop will be executed if the variable <code>i</code> is less than 10.
				Finally, the code inside the while loop sets the value of the variable <code>i</code> to whatever <code>i</code> is, plus one (remember that the increment operator (++) increases its operand's value by one).
			</p>
			<p>
				This last bit may be confusing for you, especially if you look at it from a math-tinted lense: in math, statements of equality must be true.
				However, this is computer science now, and we aren't making a statement of equality (that would be <code>==</code>): we are assigning a variable to a value.
				When the computer does this, it first evaluates whatever expression is on the right, and then sets the variable on the left to that expression.
				We can then see that <code>i++</code> evaluates to i + 1, so the whole statement sets the value of <code>i</code> to whatever <code>i</code> was, plus one.
			</p>
			<p>
				So what does this code actually do? For beginning CS students, it is normally very helpful to create a table:
			</p>
		</h3>
		<table>
			<tr>
				<th>loop #</th>
				<th>val <code>i</code></th>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>3</td>
				<td>3</td>
			</tr>
			<tr>
				<td>4</td>
				<td>4</td>
			</tr>
			<tr>
				<td>5</td>
				<td>5</td>
			</tr>
			<tr>
				<td>6</td>
				<td>6</td>
			</tr>
			<tr>
				<td>7</td>
				<td>7</td>
			</tr>
			<tr>
				<td>8</td>
				<td>8</td>
			</tr>
			<tr>
				<td>9</td>
				<td>9</td>
			</tr>
			<tr>
				<td>10</td>
				<td>10</td>
			</tr>
		</table>
		<h3>
			<p>
				On the left hand side we have the number of completed loops, while on the right hand side, we have the value of <code>i</code>.
				The 0th loop is the state of our variable before the loop starts.
				As you can see, each time the loop runs, <code>i</code> is incremented by one.
				After the 10th iteration, the value of <code>i</code> equals ten, which makes our condition <code>i &lt; 10</code> false.
				This will cause the loop to end and program execution will move on.
			</p>
			<p>
				So this code doesn't actually do anything, per se, because it just runs 10 times and then program execution moves beyond the loop.
				However, we could easily modify this code to do something by putting some additional statements in the block:
			</p>
			<div class="codeinset">
				<code>int i = 0;</code><br>
				<code>WHILE (i &lt; 10):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;i = i++;</code><br>
				<code>&emsp;&emsp;do something;</code><br>
				<code>&emsp;&emsp;do something else;</code><br>
				<code>}</code><br>
			</div>
		</h3>
		
		<h2>Traversing Arrays</h2>
		
		<h3>
			<p>
				Now that we've learned about variables, data, datastructures, and control structures, we can put them together to <i>traverse</i> an array.
				Traversing an array refers to using a loop to do something to all of the values in an array in order.
				To do this, let's think back to the last example array we had:
			</p>
			<div class="codeinset">
				<code>int i = 0;</code><br>
				<code>WHILE (i &lt; 10):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;i = i++;</code><br>
				<code>}</code><br>
			</div>
			<p>
				We noticed that each loop iteration, <code>i</code> becomes greater by one.
				Since array index values also increase by one for each sequential value, let's see if we can use this to our advantage to sum up the values in an integer array.
				If you wanted to find the sum of a list of numbers, for example the numbers 1, 2, 3, 4, and 5, what would you do?
				I'd bet you'd first create a type of running tally in your mind, which starts at 0, and then you add all of the numbers to it one by one.
				Let's do something similar:
			</p>
			<div class="codeinset">
				<code>integerArray = [1, 2, 3, 4, 5]</code><br>
				<code>int i = 0;</code><br>
				<code>int sum = 0;</code><br>
				<code>WHILE i &lt; 5:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;sum = sum + integerArray[i];</code><br>
				<code>&emsp;&emsp;i = i + 1;</code><br>
				<code>}</code><br>
			</div>
			<p>
				Since datastructures are variables, we can create them like we create normal integer variables, listing the values in a bracketed list separated by commas.
				When we refer to datastructure values, we normally do it using bracket notation, like this: <code>datastructureName[key]</code>.
				If the datastructure is an array, the key will be an integer. If the datastructure is a dictionary, the key will be a string.
				In this case, <code>integerArray</code> is our array, containing the values <code>1, 2, 3, 4, 5</code>, and <code>integerArray[i]</code> refers to the value at the <code>i</code>th index of the array.
			</p>
			<p>
				We can see clearly that we start the loop with a variable <code>i</code> and a variable <code>sum</code>, both equal to 0.
				We can also see that the loop will only run when <code>i</code> is less than 5, and each loop, <code>i</code> is increased by one; thus, the loop will run five times.
				<code>i</code> functions as the index pointer, which allows us to select each array value in order, while <code>sum</code> functions as our tally.
				Let's construct a table of values and think about what this is doing:
			</p>
		</h3>
		<table>
			<tr>
				<th>Loop #</th>
				<th><code>i</code></th>
				<th><code>integerArray[i]</code></th>
				<th><code>sum</code></th>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>3</td>
				<td>3</td>
			</tr>
			<tr>
				<td>3</td>
				<td>3</td>
				<td>4</td>
				<td>6</td>
			</tr>
			<tr>
				<td>4</td>
				<td>4</td>
				<td>5</td>
				<td>10</td>
			</tr>
			<tr>
				<td>5</td>
				<td>5</td>
				<td>N/A</td>
				<td>15</td>
			</tr>
		</table>
		<h3>
			<p>
				Our columns are the loop number, the value of <code>i</code>, the value of <code>integerArray[i]</code>, and the value of <code>sum</code>.
				When the loop number is 0 it represents the state of the variables before the loop starts.
				When the loop number is 5 it represents the state of the variables after the loop ends.
				Any number in between is the state of the variables after that number loop.
			</p>
			<p>
				During the first iteration of the loop, <code>integerArray[i]</code> is equal to <code>integerArray[0]</code> which equals 1.<br>
				During the second iteration, <code>integerArray[i]</code> is equal to <code>integerArray[1]</code> which equals 2.<br>
				This continues until the last (fifth) iteration, when <code>i</code> equals 4, so <code>integerArray[i]</code> is equal to <code>integerArray[4]</code> which equals 5.
				The value of <code>i</code> increases from 0 to 4 over the course of the iterations, and the indicies of the <code>integerArray</code> array also span the numbers from 0 to 4, so we can sequencially select all of the values in the array.
				If we take the value of <code>sum</code> and the value of <code>integerArray[i]</code> and add them, we get the <code>sum</code> for the next loop iteration.
				Doing this for all values of <code>i</code> (and thus all values in <code>integerArray</code>) allows us to sum up all of the numbers.
			</p>
			<p>
				I feel like right now it's important to stress that the code above isn't real code you could run in Java or Python or probably any other language, and <i>that doesn't matter</i>.
				Sure, the code is decently close to the syntax for those languages, but the real value here is understanding the idea of traversing an array using a loop, summing the values as you go.
				If we think back to how we would mentally do the calculation, we can construct a chart of what we'd do:
			</p>
		</h3>
		<table>
			<tr>
				<th>tally</th>
				<th>number to add</th>
			</tr>
			<tr>

				<td>0</td>
				<td>1</td>
			</tr>
			<tr>

				<td>1</td>
				<td>2</td>
			</tr>
			<tr>

				<td>3</td>
				<td>3</td>
			</tr>
			<tr>

				<td>6</td>
				<td>4</td>
			</tr>
			<tr>

				<td>10</td>
				<td>5</td>
			</tr>
			<tr>

				<td>15</td>
				<td>N/A</td>
			</tr>
		</table>
		<h3>
			<p>
				It's basically the same chart; the only difference is that the number to add was stored in a list of numbers in a computer, and we needed a counter number (<code>i</code>) to keep track of which list item to add next.
				Let's try it again but with different values in the array:
			</p>
			<div class="codeinset">
				<code>integerArray = [4, 6, 8, 9, 10]</code><br>
				<code>int i = 0;</code><br>
				<code>int sum = 0;</code><br>
				<code>WHILE i &lt; 5:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;sum = sum + integerArray[i];</code><br>
				<code>&emsp;&emsp;i = i + 1;</code><br>
				<code>}</code><br>
			</div>
		</h3>
		<table>
			<tr>
				<th>Loop #</th>
				<th><code>i</code></th>
				<th><code>integerArray[i]</code></th>
				<th><code>sum</code></th>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>4</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>6</td>
				<td>4</td>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>8</td>
				<td>10</td>
			</tr>
			<tr>
				<td>3</td>
				<td>3</td>
				<td>9</td>
				<td>18</td>
			</tr>
			<tr>
				<td>4</td>
				<td>4</td>
				<td>10</td>
				<td>27</td>
			</tr>
			<tr>
				<td>5</td>
				<td>5</td>
				<td>N/A</td>
				<td>37</td>
			</tr>
		</table>
		<h3>
			<p>
				I'd like to stress again that the implementation (the actual code) isn't important, but the concept is what we're after.
				It's the same as if you tried to add the numbers 4, 6, 8, 9, and 10 in your head: you'd keep a running tally and add them all in sequence.
			</p>
			<p>
				The next logical thing to do is traverse the array backwards, because, honestly, why not?
				To do this, let's think about what our <code>i</code> values must do: we want to start at the largest array index and go all the way back down to index 0, so our <code>i</code> should do the same thing.
				Let's try that last example again, but adding backwards:
			</p>
			<div class="codeinset">
				<code>integerArray = [4, 6, 8, 9, 10]</code><br>
				<code>int i = 4;</code><br>
				<code>int sum = 0;</code><br>
				<code>WHILE i &gt;= 0:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;sum = sum + integerArray[i];</code><br>
				<code>&emsp;&emsp;i = i - 1;</code><br>
				<code>}</code><br>
			</div>
		</h3>
		<table>
			<tr>
				<th>Loop #</th>
				<th><code>i</code></th>
				<th><code>integerArray[i]</code></th>
				<th><code>sum</code></th>
			</tr>
			<tr>
				<td>0</td>
				<td>4</td>
				<td>10</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>3</td>
				<td>9</td>
				<td>10</td>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>8</td>
				<td>19</td>
			</tr>
			<tr>
				<td>3</td>
				<td>1</td>
				<td>6</td>
				<td>27</td>
			</tr>
			<tr>
				<td>4</td>
				<td>0</td>
				<td>4</td>
				<td>33</td>
			</tr>
			<tr>
				<td>5</td>
				<td>-1</td>
				<td>N/A</td>
				<td>37</td>
			</tr>
		</table>
		<h3>
			<p>
				And now, sideways! But what happened there?
				<code>i</code> started at 4 and went down to 0, so the index number started at 4 and went down to 0.
				This meant we accessed the array values backwards, starting at the last one and going to the first one.
				Our summation didn't change, though.
			</p>
			<p>
				Going backwards is actually vital in some applications: consider what happens if you traverse forwards and delete an item.
				Then your array is one item shorter, and the "next" item which you need to access is in the same spot as the one you just deleted.
				If you increase your <code>i</code> by one, you will completely skip that item, which is no good.
				However, if you traverse backwards, you avoid that issue.
			</p>
			<p>
				The last thing I want to mention is what happens when you try to access an array value which doesn't exist.
				Say we have the code segment from the beginning of this section:
			</p>
			<div class="codeinset">
				<code>integerArray = [1, 2, 3, 4, 5]</code><br>
				<code>int i = 0;</code><br>
				<code>int sum = 0;</code><br>
				<code>WHILE i &lt; 5:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;sum = sum + integerArray[i];</code><br>
				<code>&emsp;&emsp;i = i + 1;</code><br>
				<code>}</code><br>
			</div>
			<p>
				Now, let's change the condition to the following:
			</p>
			<div class="codeinset">
				<code>integerArray = [1, 2, 3, 4, 5]</code><br>
				<code>int i = 0;</code><br>
				<code>int sum = 0;</code><br>
				<code>WHILE i &lt; 6:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;sum = sum + integerArray[i];</code><br>
				<code>&emsp;&emsp;i = i + 1;</code><br>
				<code>}</code><br>
			</div>
			<p>
				What will happen is that there will be six loop iterations rather than five loop iterations, because <code>i</code> can vary from 0 to 5 rather than 0 to 4, as before.
				This means that on the last iteration, the statement <code>sum = sum + integerArray[i]</code> will throw an <i>error</i>, which means we gave the computer an invalid instruction.
				If we look at our table for this particular loop, we might be able to divine why we got an error:
			</p>
		</h3>
		<table>
			<tr>
				<th>Loop #</th>
				<th><code>i</code></th>
				<th><code>integerArray[i]</code></th>
				<th><code>sum</code></th>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>2</td>
				<td>1</td>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
				<td>3</td>
				<td>3</td>
			</tr>
			<tr>
				<td>3</td>
				<td>3</td>
				<td>4</td>
				<td>6</td>
			</tr>
			<tr>
				<td>4</td>
				<td>4</td>
				<td>5</td>
				<td>10</td>
			</tr>
			<tr>
				<td>5</td>
				<td>5</td>
				<td>N/A</td>
				<td>15</td>
			</tr>
			<tr>
				<td>6</td>
				<td>6</td>
				<td>N/A</td>
				<td>15</td>
			</tr>
		</table>
		<h3>
			<p>
				Our code told the computer to add the value of <code>sum</code>, which was 15, to the value of <code>integerArray[5]</code>.
				The problem is that <code>integerArray[5]</code> doesn't exist, because the array only has five elements at array indicies 0 to 4.
				Thus, our code would throw an <code>IndexOutOfBoundsError</code>, which happens if we try to access any invalid index (anything less than 0 or more than the length of the array minus one).
			</p>
			<p>
				I know that loops are hard, and thinking about them can make your brain hurt.
				However, take some consolation in the knowledge that like all difficult things, if you do lots of practice, it'll become much easier.
				Additionally, if you know that a loop is traversing an array - a huge hint will be if there is a variable like our <code>i</code> which happens to go through all of the index values -
				you can generally use heuristics to intuit what the loop is doing, rather than having to chart out the whole thing.
			</p>
		</h3>
		
		<h2>In Conclusion</h2>
		
		<h3>
			<p>
				We learned that:<br>
				- There are three control structures: sequence, conditional, and iterative.<br>
				- There are three conditional types: <code>if</code>, <code>else if</code>, and <code>else</code>.<br>
				- A <code>while</code> loop acts like a repeating <code>if</code> statement.<br>
				- Traversing an array means to use a loop to do something to every element in an array, in order.<br>
				- If we want to sum the contents of an array, we need to create a variable to store a running tally, and then add each array element sequentially.<br>
				- Sometimes, we might want to traverse backwards to avoid issues stemming from changing the amount of items in the array.<br>
				- If we try to access an element which does not exist, we will get an <code>IndexOutOfBoundsError</code>
			</p>
			<p>
				Next, please check out the <a target="_self" href="procedural-programming.html">Procedural Programming</a> page.
			</p>
		</h3>
		<hr>
		<h4><p><a target="_self" href="../index.html">Home</a>&emsp;&emsp;&emsp;&emsp;<a target="_self" href="#">Back to Top</a></p></h4>
	</div>
</body>

</html>
<!DOCTYPE HTML>
<html lang="en-US">

<head>
	<meta charset="UTF-8">

	<link rel="shortcut icon" href="../resources/favicon.jpg">
	<title>Binary Numbers</title>
	
	<link rel="stylesheet" type="text/css" href="../styles/base.css">
	<link rel="stylesheet" type="text/css" href="../styles/scrollbar.css">
	<base target="_blank">
</head>

<body>
	<div id="bodycontent">
	
		<br>
		<h4><p><a target="_self" href="../index.html">Home</a></p></h4>
		<h1 id="Title">Binary Numbers</h1>
		<hr>
		
		<h2>Bases and Positional Notation</h2>

		<h3>
			<p>
				To understand binary numbers, we first have to understand a little more about our own number system, which is based on <i>Base 10</i>.
				In Base 10, we have a total of 10 digits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9), which we use in conjunction with something called <i>positional notation</i> to write our numbers.
				If we write some number, say 6,283.475, we are saying that there are 6 thousands, 2 hundreds, 8 tens, 3 ones, 7 tenths, 4 hundredths, and 5 thousandths.
				We use the digits to relate how many of each place value we have, and then add them all up.
				These place values may have seemed a bit arbitrary when you first learned them, but there is actually a very special reason we use those numbers: each position (the 1s, 10s, 100s, etc) is a power of 10.
				For further clarification, see the below table:
			</p>
		</h3>
		
		<table class="largetable">
			<tr>
				<td>10<sup>3</sup> 's</td>
				<td>10<sup>2</sup> 's</td>
				<td>10<sup>1</sup> 's</td>
				<td>10<sup>0</sup> 's</td>
				<td>10<sup>-1</sup> 's</td>
				<td>10<sup>-2</sup> 's</td>
				<td>10<sup>-3</sup> 's</td>
			</tr>
			<tr>
				<td>1000's</td>
				<td>100's</td>
				<td>10's</td>
				<td>1's</td>
				<td>0.1's</td>
				<td>0.01's</td>
				<td>0.001's</td>
			</tr>
			<tr>
				<td>6,</td>
				<td>2</td>
				<td>8</td>
				<td>3.</td>
				<td>7</td>
				<td>4</td>
				<td>5</td>
			</tr>
		</table>
		
		<h3>
			<p>
				In the above table, we see the number 6,283.745; what this means is that we have 6 10<sup>3</sup> 's, 2 10<sup>2</sup> 's, 8 10<sup>1</sup> 's, 3 10<sup>0</sup> 's, 7 10<sup>-1</sup> 's, 4 10<sup>-2</sup> 's, and 5 10<sup>-3</sup> 's, all added together.
				This can also be written as we did before, as 6 thousands, 2 hundreds, 8 tens, 3 ones, 7 tenths, 4 hundredths, and 5 thousandths, or as
				6*1000 + 2*100 + 8*10 + 3*1 + 7/10 + 4/100 + 5/1000.
				So what does this have to do with binary?
				Binary is just Base 2. That means that we only have 2 digits, 1 and 0, to use in our positional notation place value system.
				Let's look at another table:
			</p>
		</h3>
		
		<table class="largetable">
			<tr>
				<td>2<sup>3</sup> 's</td>
				<td>2<sup>2</sup> 's</td>
				<td>2<sup>1</sup> 's</td>
				<td>2<sup>0</sup> 's</td>
				<td>2<sup>-1</sup> 's</td>
				<td>2<sup>-2</sup> 's</td>
				<td>2<sup>-3</sup> 's</td>
			</tr>
			<tr>
				<td>8's</td>
				<td>4's</td>
				<td>2's</td>
				<td>1's</td>
				<td>1/2's</td>
				<td>1/4's</td>
				<td>1/8's</td>
			</tr>
			<tr>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1.</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
		</table>
		
		<h3>
			<p>
				What does this mean? We now have the binary number 1011.011; it has only two digits, representing how many of each positional value we have.
				We have 1 eight, 0 fours, 1 two, 1 one, 0 halves, 1 fourth, and 1 eighth.
				We could also say that we have 1 2<sup>3</sup> 's, 0 2<sup>2</sup> 's, 1 2<sup>1</sup> 's, 1 2<sup>0</sup> 's, 0 2<sup>-1</sup> 's, 1 2<sup>-2</sup> 's, and 1 2<sup>-3</sup> 's, all added together.
				In base ten, we would represent this number as 8 + 2 + 1 + 1/4 + 1/8 = 11 + 3/8 = 11.375. That is to say, 1011.011<sub>2</sub> = 11.375<sub>10</sub>.
				As you can see, we use subscripts to clarify what base a number is in.
				You can assume that if there is a subcript 2 like this: 101101001101<sub>2</sub>, it is in base 2, while if there is no subscript, it is in base 10.
				Extra challenge: what is 101101001101<sub>2</sub> in base 10? Hover here to reveal the answer: | <span class="reveal">2893</span> |
			</p>
		</h3>
		
		<h2>Binary as Data</h2>
		
		<h3>
			<p>
				Binary is really nice for usage within digital systems, such as computers, because they only have two states: 1 and 0; true and false; on and off.
				A circuit with high voltage is considered a 1, while a circuit with low or no voltage is considered a 0.
				When we write binary numbers in the context of computers, we have a few special terms to use with them: we call a single digit in a binary number a <i>bit</i>, we call a sequence of 8 bits a <i>byte</i>, and we call a sequence of four bits, half a byte, a <i>nibble</i>.
				So in the number 10110100<sub>2</sub>, each 1 or 0 is a bit, therefore there are eight bits in the number. This means that the number is a single byte of data, or two nibbles of data.
				I don't know the origins of those terms, but they are very important for a thorough understanding of binary.
			</p>
		</h3>
		
		<h2>Operators</h2>
		
		<h3>
			<p>
				Now, we need to talk about arithmetic and logical operations on binary numbers.
				An <i>operation</i> is something which tells you what to do with a value or several values, called <i>operands</i>.
				Operators can be <i>unary</i>, meaning they only operate on one operand, or <i>binary</i>, meaning they operate on two operands.
				Operators which operate on n values are called n-ary operators, but we won't worry about anything beyond unary or binary for now.
				Examples of binary operators are the arithmetic operations (addition, subtraction, multiplication, and division) and exponentiation.
				Examples of unary operators would be absolute value (|x|), factorial (x!), or inverse (the additive inverse is -x while the multiplicative inverse is 1/x).
			</p>
			<p>
				For binary numbers, we actually have some other operations which we didn't have for base 10: NOT, AND, OR, and XOR, all of which are binary except for NOT, which is unary.
				These are known as <i>bitwise operators</i>, because they operate on pairs of bits between two binary numbers. 
			</p>
		</h3>
		
		<h2>NOT</h2>
		
		<h3>
			<p>
				NOT (also known as the <i>logical complement</i>) is a unary bitwise operator which effectively flips each bit of the operand.
				For example, the operation NOT 1101<sub>2</sub> results in 0010<sub>2</sub>.
				Likewise, NOT 0010<sub>2</sub> results in 1101<sub>2</sub>.
				This tells us that NOT NOT n is equal to the original n, meaning that it effectively undoes itself.
				NOT NOT NOT NOT NOT n = NOT n, because the first four NOT's cancel out.
				Please note that NOT is generally symbolized by an exclamation point, so !x means NOT x.
			</p>
		</h3>
		
		<h2>AND</h2>
		
		<h3>
			<p>
				AND is a binary bitwise operator which compares each pair of bits in the same position in the two operands, setting the output bit in that position based on the values of the pair of input bits.
				If both input bits are 1, so operand 1's bit AND operand 2's bit are both 1, the result's bit in that same place will be 1. If either operand's bit is a 0 (or if both are 0), the output bit in that place will be 0.
				So for example, 1101<sub>2</sub> AND 1001<sub>2</sub> results in 1001<sub>2</sub>. This can be seen better by stacking the two numbers on top of each other:
			</p>
		</h3>
		
		<table>
			<tr>
				<td></td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>&</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>=</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
		</table>
		
		<h3>
			<p>
				If a 1 and a 1 are on top of each other, the result in that place is a 1. Otherwise the result is a 0 there.
				Pretty simple. Notice that the symbol for the AND operation is the &. Another example where each operand is a full byte:
			</p>
		</h3>
		
		<table>
			<tr>
				<td></td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>&</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>=</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
		</table>
		
		<h2>OR</h2>
		
		<h3>
			<p>
				OR, like AND, is a binary bitwise operator which compares each pair of bits in the same position in the two operands, setting the output bit in that position based on the values of the pair of input bits.
				If one input bit (or both) are 1, so operand 1's value at that place OR operand 2's value at that place is 1, the result in that place will be a 1. The only way to get a 0 is to get two input 0's.
				So for example, 1101<sub>2</sub> OR 1001<sub>2</sub> results in 1101<sub>2</sub>. This can be seen better by stacking the two numbers on top of each other:
			</p>
		</h3>
		
		<table>
			<tr>
				<td></td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>|</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>=</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
			</tr>
		</table>
		
		<h3>
			<p>
				If either place has a 1, the result is a 1. If both are 0, the result is a 0.
				Notice that the symbol for the OR operation is the |. Another example where each operand is a full byte:
			</p>
		</h3>
		
		<table>
			<tr>
				<td></td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>|</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>=</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
		</table>
		
		<h2>XOR</h2>
		
		<h3>
			<p>
				XOR, like AND and OR, is a binary bitwise operator which compares each pair of bits in the same position in the two operands, setting the output bit in that position based on the values of the pair of input bits.
				XOR is like a restrictive form of OR, so if either operand 1's value OR operand 2's value are 1, the result is a 1. However, if both operands' values are 1, the result is a 0. If both operands' values are 0, the result is also 0.
				So for example, 1101<sub>2</sub> XOR 1001<sub>2</sub> results in 0100<sub>2</sub>. This can be seen better by stacking the two numbers on top of each other:
			</p>
		</h3>
		
		<table>
			<tr>
				<td></td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>^</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>=</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
			</tr>
		</table>
		
		<h3>
			<p>
				If a 1 and another 1 are on top of each other, or if a 0 and another 0 are on top of each other, the result is a 0.
				To get a 1, only one input can be a 1.
				Notice that XOR is represented by a ^. Another example where each operand is a full byte:
			</p>
		</h3>
		
		<table>
			<tr>
				<td></td>
				<td>1</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>^</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
			</tr>
			<tr>
				<td>=</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>1</td>
				<td>0</td>
			</tr>
		</table>
			
			
		<h3>
			<p>I also strongly suggest that you visit the wikipedia page on bitwise operators for more in-depth information: <a href="https://en.wikipedia.org/wiki/Bitwise_operation">Bitwise Operations</a></p>
		</h3>
		
		<h2 id="two's-complement">Two's Complement</h2>
		
		<h3>
			<p>
				You may have read all of this and wondered "Hey, where are the negative numbers? How can you perform a bitwise operation on the minus sign?".
				Well, the short answer is that you don't.
				You have to use the bits in the number to represent both positive and negative numbers, and the way you do that is with <i>Two's Complement</i>.
			</p>
			<p>
				To understand Two's Complement, we have to first recognize that in a 4 bit number, there are 16 possible values (0 - 15 or 0000<sub>2</sub> - 1111<sub>2</sub>).
				Similarly, in an 8 bit number, there are 256 possible values: 0 - 255 or 00000000<sub>2</sub> - 11111111<sub>2</sub>.
				However, what we do with Two's Complement is decide that the first half of those values, 0 to 127 in the 8 bit case, will represent the numbers 0 to 127, while the numbers 128 to 256 will represent the numbers -128 to -1.
				A little confusing, right? Let's use a chart to see what happens as we go up in values in a 4 bit number, and hopefully make it a little more clear.
			</p>
		</h3>
		
		<table>
			<tr>
				<td>0000</td>
				<td>0</td>
				<td>0</td>
				<td>0000</td>
			</tr>
			<tr>
				<td>0001</td>
				<td>1</td>
				<td>1</td>
				<td>0001</td>
			</tr>
			<tr>
				<td>0010</td>
				<td>2</td>
				<td>2</td>
				<td>0010</td>
			</tr>
			<tr>
				<td>0011</td>
				<td>3</td>
				<td>3</td>
				<td>0011</td>
			</tr>
			<tr>
				<td>0100</td>
				<td>4</td>
				<td>4</td>
				<td>0100</td>
			</tr>
			<tr>
				<td>0101</td>
				<td>5</td>
				<td>5</td>
				<td>0101</td>
			</tr>
			<tr>
				<td>0110</td>
				<td>6</td>
				<td>6</td>
				<td>0110</td>
			</tr>
			<tr>
				<td>0111</td>
				<td>7</td>
				<td>7</td>
				<td>0111</td>
			</tr>
			<tr>
				<td>1000</td>
				<td>8</td>
				<td>-8</td>
				<td>0111</td>
			</tr>
			<tr>
				<td>1001</td>
				<td>9</td>
				<td>-7</td>
				<td>0110</td>
			</tr>
			<tr>
				<td>1010</td>
				<td>10</td>
				<td>-6</td>
				<td>0101</td>
			</tr>
			<tr>
				<td>1011</td>
				<td>11</td>
				<td>-5</td>
				<td>0100</td>
			</tr>
			<tr>
				<td>1100</td>
				<td>12</td>
				<td>-4</td>
				<td>0011</td>
			</tr>
			<tr>
				<td>1101</td>
				<td>13</td>
				<td>-3</td>
				<td>0010</td>
			</tr>
			<tr>
				<td>1110</td>
				<td>14</td>
				<td>-2</td>
				<td>0001</td>
			</tr>
			<tr>
				<td>1111</td>
				<td>15</td>
				<td>-1</td>
				<td>0000</td>
			</tr>
		</table>
		
		<h3>
			<p>
				We have four columns: from the left, the first one is the binary numbers from 0 to 15; the second one is the decimal numbers from 0 to 15; the third column is the two's complement meaning of each number; the fourth column is the binary representation of the two's complement number but inverted.
				As you can see, we can use 4 bits, which would normally represent the numbers 0 to 15, to represent the numbers -8 to +7.
				Another thing that you can notice is that for the negative numbers, the fourth column is exactly the inverse of the first one.
			</p>
			<p>
				What this means is that if you want to convert from a positive number to it's respective negative number in two's complement representation, just subtract one from the binary representation of the positive number and then invert it.
				To get -2 from 2, take 0010<sub>2</sub>, subtract 1 to get 0001<sub>2</sub>, and then invert it to get 1110<sub>2</sub>.
				This gives you the binary representation of -2 using two's complement.
				Similarly, to convert from a two's complement negative number to a positive number, subtract one and then invert it.
				For example, to get from -3 to 3, we take the two's complement representing -3, which is 1101<sub>2</sub>, subtract one to get 1100<sub>2</sub>, and then invert it to get 0011<sub>2</sub>, which indeed does equal 3.
				Basically, to convert back and forth, first subtract one, then apply logical complement (NOT) to invert it.
			</p>
			<p>
				This might seem really convoluted as a method of writing negative numbers, but it has the advantage that performing the arithmetic operations on unsigned (non-two's complement/only positive) binary numbers is identical to performing it on two's complement numbers.
				Knowing the ins and outs of binary numbers isn't important as a rule when programming, and you could probably get by without it, but depending on what type of work you end up doing, it comes in very handy.
				In any case, I'm a firm believer in knowing things for the sake of knowing more about the world, so in my opinion knowing this information is inherently valuable, no justification required.
			</p>
			<p>
				Additionally, I strongly encourage a visit to the wikipedia page on two's complement for further information, as well as more nice charts: <a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two's Complement</a>.
			</p>
		</h3>
		<hr>
		<h4><p><a target="_self" href="../index.html">Home</a>&emsp;&emsp;&emsp;&emsp;<a target="_self" href="#">Back to Top</a></p></h4>
	</div>
</body>

</html>